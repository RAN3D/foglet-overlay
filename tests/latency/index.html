<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>latency exemple</title>
    <script src='../../dist/overlay.bundle.js'></script>
    <script src='../../node_modules/p2p-graph/p2p-graph.min.js'></script>
    <style>
      .graph {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <div id='cycle'></div>
    <div id='verified'></div>
    <div id='convergence'></div>
    <div id='graph'></div>
    <script>
      console.log(overlay)
      localStorage.debug = '-core:*,overlay*'
      let foglets = [];
      const max = 10;
      let cycle = 0;
      const reloadTime =10000;
      let graph = undefined;
      let revertedIndex = new Map();
      let revertedName = new Map();
      let latencies = [];
      for(let i = 0; i<max;++i){
        let temp_latencies = [];
        for(let j=0;j<max;j++) {
          temps_latencies.push(j);
        }
        latencies.push(temps_latencies);
      }
      for(let i = 0; i<max;++i){
        for(let j=0;j<max;j++) {
          if( i === j) {
            latencies[i][j] = 0;
          } else {
            latencies[i][j] = i+j;
            latencies[j][i] = i+j;
          }
        }
        foglets.push(new overlay.foglet.Foglet({
          overlays: [
            {
              name: 'latency',
              class: overlay.latencyOverlay,
              options: {
                fakeRtt: {model: latencies},
                partialViewSize: 1,
                delta: reloadTime,
                timeout: 10000,
                protocol: "testsoverlaylatency",
                signaling: {
                  address: "https://signaling.herokuapp.com/",
                  room: "stests"
                }
              }
            }
          ]
        }))
        revertedIndex.set(foglets[i].inViewID, foglets[i].id);
        revertedName.set(foglets[i].inViewID, i);
      }
      console.table(latencies);

      foglets.reduce((prev, cur, ind) => {
        cur.share();
        return cur.connection();
      }, Promise.resolve())

      function createGraph() {
        document.getElementById('graph').innerHTML = "<div class='graph'></div>";
        graph = new window.P2PGraph('.graph');
        for(let i=0;i<max;++i){
          graph.add({
            id: foglets[i].id,
            name: i+1,
            me: false
          });
        }
        for(let i =0;i<max;++i){
          foglets[i].overlay('latency').network.getNeighbours().forEach(peer => {
            !graph.hasLink(foglets[i].id, revertedIndex.get(peer)) &&
              graph.connect(foglets[i].id, revertedIndex.get(peer));
          });
        }
        cycle++;
        document.getElementById('cycle').innerHTML = 'Cycle: '+cycle;
        verify();
      }

      setTimeout(createGraph, reloadTime);
      setTimeout(setInterval(reloadGraph, reloadTime), reloadTime);

      function reloadGraph() {
        graph.destroy();
        document.getElementById('graph').innerHTML = "<div class='graph'></div>";
        graph = new window.P2PGraph('.graph');
        for(let i=0;i<max;++i){
         graph.add({
          id: foglets[i].id,
          name: i,
          me: false
         });
        }
        for(let i =0;i<max;++i){
          foglets[i].overlay('latency').network.getNeighbours().forEach(peer => {
            !graph.hasLink(foglets[i].id, revertedIndex.get(peer)) &&
              graph.connect(foglets[i].id, revertedIndex.get(peer));
          });
        }
        cycle++;
        document.getElementById('cycle').innerHTML = 'Cycle: '+cycle;
        setTimeout(verify, 1000);
      }

      function verify() {
        function Result (fogId, check, totalFalse, totalTrue){
          this.fogId = fogId;
          this.check = check;
          this.totalFalse = totalFalse;
          this.totalTrue = totalTrue;
        }
        let falseNb = 0, trueNb = 0;
        let table = [];
        foglets.forEach(fog=> {
          let neigh = fog.overlay('latency').network.getNeighbours();
          let check = true;
          neigh.forEach(peer => {
            if(revertedName.get(peer) < revertedName.get(fog.inViewID)) {
              check = check && true;
            } else {
              check= check && false;
            }
          })
          if(check)
            trueNb++;
          else
            falseNb++;
          table.push(new Result(revertedName.get(fog.inViewID), check, falseNb, trueNb));
        });
        table.push(table);
        console.clear()
        console.table(table, ["fogId", "check", "totalFalse", "totalTrue"]);
        if(falseNb === 1 && trueNb === max-1) document.getElementById('verified').innerHTML = "Verified at cycle:"+cycle;
        const convergence = (max-falseNb)/max * 100
        console.log('Convergence: ', (max-falseNb)/max * 100);
        document.getElementById('verified').innerHTML = "Convergence: "+convergence+"%";
      }
    </script>
  </body>

</html>
