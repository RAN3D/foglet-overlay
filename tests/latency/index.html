<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>latency exemple</title>
    <script src='../../dist/overlay.bundle.js'></script>
    <script src='../../node_modules/p2p-graph/p2p-graph.min.js'></script>
    <style>
      .graph {
        width: 100%;
        height: 100%;      
      }           
    </style>
  </head>

  <body>
    <div id='cycle'></div>
    <div id='verified'></div>
    <div id='graph'></div>
    <script>
      console.log(overlay)
      localStorage.debug = '-core:*,overlay*'
      let foglets = [];
      const max = 10;
      let cycle = 0;
      const reloadTime =10000;
      let graph = undefined;
      let revertedIndex = new Map();
      let revertedName = new Map();

      for(let i = 0; i<max;++i){
        foglets.push(new overlay.foglet.Foglet({
          overlays: [
            {
              name: 'latency',
              class: overlay.latencyOverlay,
              options: {
                fakeRtt: i+1,
                partialViewSize: 1,
                delta: reloadTime,
                timeout: 10000,
                protocol: "testsoverlaylatency",
                signaling: {
                  address: "https://signaling.herokuapp.com/",
                  room: "stests"
                }
              }
            }
          ]
        }))
        revertedIndex.set(foglets[i].inViewID, foglets[i].id);
        revertedName.set(foglets[i].inViewID, i);
      }

      foglets.reduce((prev, cur, ind) => {
        cur.share();
        return cur.connection();
      }, Promise.resolve())

      function createGraph() {
        document.getElementById('graph').innerHTML = "<div class='graph'></div>";
        graph = new window.P2PGraph('.graph');
        for(let i=0;i<max;++i){
          graph.add({
            id: foglets[i].id,
            name: i+1,
            me: false
          });
        }
        for(let i =0;i<max;++i){
          foglets[i].overlay('latency').network.getNeighbours().forEach(peer => {
            !graph.hasLink(foglets[i].id, revertedIndex.get(peer)) &&
              graph.connect(foglets[i].id, revertedIndex.get(peer));
          });
        }
        cycle++;
        document.getElementById('cycle').innerHTML = 'Cycle: '+cycle;
        verify();
      }

      setTimeout(createGraph, reloadTime);
      setTimeout(setInterval(reloadGraph, reloadTime), reloadTime);

      function reloadGraph() {
        graph.destroy();
        document.getElementById('graph').innerHTML = "<div class='graph'></div>";
        graph = new window.P2PGraph('.graph');
        for(let i=0;i<max;++i){
         graph.add({
          id: foglets[i].id,
          name: i,
          me: false
         });
        }
        for(let i =0;i<max;++i){
          foglets[i].overlay('latency').network.getNeighbours().forEach(peer => {
            !graph.hasLink(foglets[i].id, revertedIndex.get(peer)) &&
              graph.connect(foglets[i].id, revertedIndex.get(peer));
          });
        }
        cycle++;
        document.getElementById('cycle').innerHTML = 'Cycle: '+cycle;
        verify()
      }

      function verify() {
        let falseNb = 0, trueNb = 0;
        foglets.forEach(fog=> {
          let neigh = fog.overlay('latency').network.getNeighbours();
          let check = true;
          neigh.forEach(peer => {
            if(revertedName.get(peer) < revertedName.get(fog.inViewID)) {
              check = check && true;
              console.log('Lower - Foglet: ', fog.id, ' peer: ', revertedIndex.get(peer), ' check: ', check);
            } else {
              check= check && false;
              console.log('higher - Foglet: ', fog.id, ' peer: ', revertedIndex.get(peer), ' check: ', check);
            }
          })
          if(check) 
            trueNb++;
          else 
            falseNb++;
        });
        
        if(falseNb !== 1 && trueNb !== max-1) document.getElementById('verified').innerHTML = "Verified at cycle:"+cycle;
      }
    </script>
  </body>

</html>


